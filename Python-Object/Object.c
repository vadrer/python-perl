/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.35 from the
 * contents of Object.xs. Do not edit this file, edit Object.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Object.xs"
/* Copyright 2000-2001 ActiveState
 */

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include <Python.h>
#include "PerlPyErr.h"
#include "../lang_lock.h"
#include "../lang_map.h"
#include "../thrd_ctx.h"

//compat2-3
#if PY_MAJOR_VERSION >= 3
#define PyInt_FromLong(a) PyLong_FromLong(a)
#define PyString_FromStringAndSize PyUnicode_FromStringAndSize
#define PyString_FromString PyUnicode_FromString
#define PyString_Check PyUnicode_Check
#define PyString_GET_SIZE PyUnicode_GET_SIZE
#define PyString_AS_STRING PyBytes_AS_STRING
#define PyString_AsString PyBytes_AsString
#define PyString_Size PyBytes_Size
#define PyInt_AsLong PyLong_AsLong
#define PyInt_Check PyLong_Check

#define PyArg_NoArgs(v)		PyArg_Parse(v, "")
typedef PyObject *(*intargfunc)(PyObject *, int) Py_DEPRECATED(2.5);
typedef int(*intintobjargproc)(PyObject *, int, int, PyObject *);
#endif

/* so we can use different typemaps for borrowed/owned obj refs */
typedef PyObject NewPyObject;
typedef PyObject NewPyObjectX;

extern __declspec(dllimport) PyObject * PyObject_Str(PyObject *);


extern SV* newPerlPyObject_inc(PyObject *pyo);
extern MGVTBL vtbl_free_pyo;

static int
magic_free_pyo(pTHX_ SV *sv, MAGIC *mg)
{
    dCTX;
    PyObject *pyo = INT2PTR(PyObject *, SvIV(sv));
#ifdef REF_TRACE
    printf("Unbind pyo %p\n", pyo);
#endif
    ENTER_PYTHON;
    Py_DECREF(pyo);
    ENTER_PERL;
    return 0;
}

//MGVTBL vtbl_free_pyo = {0, 0, 0, 0, magic_free_pyo};

SV*
newPerlPyObject_noinc(PyObject *pyo)
{
    ASSERT_LOCK_PERL;

    if (!pyo)
        croak("Missing pyo reference argument");

    SV* rv = newSV(0);
    SV* sv = newSVrv(rv, "Python::Object");

    sv_setiv(sv, (IV)pyo);
    sv_magic(sv, 0, '~', 0, 0);
    MAGIC* mg = mg_find(sv, '~');
    if (!mg) {
        SvREFCNT_dec(rv);
	croak("Can't assign magic to Python::Object");
    }
    mg->mg_virtual = &vtbl_free_pyo;
    printf("pyo=%08X, mg=%08X ->virtual=%08X vtbl...=%08X\n", pyo,  mg , mg->mg_virtual , &vtbl_free_pyo);
    SvREADONLY(sv);
#ifdef REF_TRACE
    printf("Bind pyo %p\n", pyo);
#endif

    ASSERT_LOCK_PERL;

    return rv;
}

SV*
newPerlPyObject_inc(PyObject *pyo)
{
    SV* sv;
    dCTX;
    ASSERT_LOCK_BOTH;
    Py_XINCREF(pyo);
    PYTHON_UNLOCK;
    sv = newPerlPyObject_noinc(pyo);
    ENTER_PYTHON;
    PERL_LOCK;
    return sv;
}


static PyObject*
PerlPyObject_pyo_or_null(SV* sv)
{
    MAGIC *mg;
    ASSERT_LOCK_PERL;

    if (SvROK(sv) && sv_derived_from(sv, "Python::Object")) {
        sv = SvRV(sv);
        mg = mg_find(sv, '~');
        if (SvIOK(sv) && mg && mg->mg_virtual == &vtbl_free_pyo) {
	    IV ival = SvIV(sv);
	    return INT2PTR(PyObject *, ival);
        }
    }
    return INT2PTR(PyObject *, 0);
}


static PyObject*
PerlPyObject_pyo(SV* sv)
{
    //printf("enter PerlPyObject_pyo sv=%08X\n", sv);
    ASSERT_LOCK_PERL;

    if (SvROK(sv) && sv_derived_from(sv, "Python::Object")) {
        sv = SvRV(sv);
	IV ival = SvIOK(sv) ? SvIV(sv) : 0;
	MAGIC *mg = mg_find(sv, '~');
        if (mg && mg->mg_virtual == &vtbl_free_pyo) {
	    if (!ival)
		croak("Null Python::Object content");
	    return INT2PTR(PyObject *, ival);
        }
        else {
	    printf("sv/ival=%08X/%08X mg=%08X ->virtual=%08X vtbl...=%08X\n", 
		sv, ival, mg , mg->mg_virtual , &vtbl_free_pyo);
            croak("Bad Python::Object content");
	}
    }
    else
	croak("Not a Python::Object");

    /* NOT REACHED */
    return NULL;
}

static SV*
newPerlPyErr()
{
    SV* sv;
    PerlPyErr *err;

    ASSERT_LOCK_PERL;
    sv = newSV(0);
    Newz(8008, err, 1, PerlPyErr);
    sv_setref_pv(sv, "Python::Err", (void*)err);
    return sv;
}

static PerlPyErr *
PerlPyErr_err(SV* sv)
{
    ASSERT_LOCK_PERL;
    if (SvROK(sv) && sv_derived_from(sv, "Python::Err")) {
	IV tmp = SvIV((SV*)SvRV(sv));
	return INT2PTR(PerlPyErr *,tmp);
    }
    else
	croak("Not a Python::Err");

    /* NOT REACHED */
    return NULL;
}


void
croak_on_py_exception()
{
    /* Enter with python lock.
       Leave through croaking with the perl lock.
     */
    dCTX;
    SV* py_err_sv;
    PerlPyErr* py_err;
    ASSERT_LOCK_PYTHON;

    ENTER_PERL;
    py_err_sv = newPerlPyErr();
    py_err = PerlPyErr_err(py_err_sv);

    ENTER_PYTHON;
    PyErr_Fetch(&py_err->type, &py_err->value, &py_err->traceback);

    ENTER_PERL;
    if (py_err->type) {
	sv_setsv(ERRSV, py_err_sv);
	SvREFCNT_dec(py_err_sv);
	ASSERT_LOCK_PERL;
	croak(Nullch);
    }
    else {
	SvREFCNT_dec(py_err_sv);
	ASSERT_LOCK_PERL;
	croak("No python exception");
    }
}


#line 221 "Object.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 365 "Object.c"

XS_EUPXS(XS_Python_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV*	sv = ST(0)
;
#line 219 "Object.xs"
     dCTX;
#line 378 "Object.c"
	NewPyObject *	RETVAL;
#line 221 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     PERL_LOCK;
     RETVAL = sv2pyo(sv);
     PYTHON_UNLOCK;
     ASSERT_LOCK_PERL;
#line 387 "Object.c"
	{
	    SV * RETVALSV;
	    RETVALSV = 0; /* because xsubpp need 'RETVALSV =' first */
	    ASSERT_LOCK_PERL;
	    RETVALSV = newPerlPyObject_noinc(RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_int); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_int)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV*	sv = ST(0)
;
#line 234 "Object.xs"
     long i;
     dCTX;
#line 413 "Object.c"
	NewPyObject *	RETVAL;
#line 237 "Object.xs"
     ASSERT_LOCK_PERL;
     i = SvIV(sv);
     ENTER_PYTHON;
     RETVAL = Py_BuildValue("l", i);
     ENTER_PERL;
#line 421 "Object.c"
	{
	    SV * RETVALSV;
	    RETVALSV = 0; /* because xsubpp need 'RETVALSV =' first */
	    ASSERT_LOCK_PERL;
	    RETVALSV = newPerlPyObject_noinc(RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_long); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_long)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV*	sv = ST(0)
;
#line 249 "Object.xs"
     dCTX;
     STRLEN my_na;
     char *s;
#line 448 "Object.c"
	NewPyObject *	RETVAL;
#line 253 "Object.xs"
     ASSERT_LOCK_PERL;
     s = SvPV(sv, my_na);
     ENTER_PYTHON;
     RETVAL = PyLong_FromString(s, NULL, 10);
     if (!RETVAL)
         croak_on_py_exception();
     ENTER_PERL;
#line 458 "Object.c"
	{
	    SV * RETVALSV;
	    RETVALSV = 0; /* because xsubpp need 'RETVALSV =' first */
	    ASSERT_LOCK_PERL;
	    RETVALSV = newPerlPyObject_noinc(RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_float); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_float)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV*	sv = ST(0)
;
#line 267 "Object.xs"
     dCTX;
     double d;
#line 484 "Object.c"
	NewPyObject *	RETVAL;
#line 270 "Object.xs"
     ASSERT_LOCK_PERL;
     d = SvNV(sv);
     ENTER_PYTHON;
     RETVAL = Py_BuildValue("d", d);
     ENTER_PERL;
#line 492 "Object.c"
	{
	    SV * RETVALSV;
	    RETVALSV = 0; /* because xsubpp need 'RETVALSV =' first */
	    ASSERT_LOCK_PERL;
	    RETVALSV = newPerlPyObject_noinc(RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_complex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_complex)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "real, imag");
    {
	double	real = (double)SvNV(ST(0))
;
	double	imag = (double)SvNV(ST(1))
;
#line 283 "Object.xs"
     dCTX;
#line 519 "Object.c"
	NewPyObject *	RETVAL;
#line 285 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     RETVAL = PyComplex_FromDoubles(real, imag);
     ENTER_PERL;
#line 526 "Object.c"
	{
	    SV * RETVALSV;
	    RETVALSV = 0; /* because xsubpp need 'RETVALSV =' first */
	    ASSERT_LOCK_PERL;
	    RETVALSV = newPerlPyObject_noinc(RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_list); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_list)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 295 "Object.xs"
     dCTX;
     int i;
#line 549 "Object.c"
	NewPyObject *	RETVAL;
#line 298 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     RETVAL = PyList_New(items);
     if (!RETVAL)
         croak_on_py_exception();
     PERL_LOCK;
     for (i = 0; i < items; i++) {
	PyList_SetItem(RETVAL, i, sv2pyo(ST(i)));
     }
     PYTHON_UNLOCK;
     ASSERT_LOCK_PERL;
#line 563 "Object.c"
	{
	    SV * RETVALSV;
	    RETVALSV = 0; /* because xsubpp need 'RETVALSV =' first */
	    ASSERT_LOCK_PERL;
	    RETVALSV = newPerlPyObject_noinc(RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_tuple); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_tuple)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 315 "Object.xs"
     dCTX;
     int i;
#line 586 "Object.c"
	NewPyObject *	RETVAL;
#line 318 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     RETVAL = PyTuple_New(items);
     if (!RETVAL)
         croak_on_py_exception();
     PERL_LOCK;
     for (i = 0; i < items; i++) {
	PyTuple_SetItem(RETVAL, i, sv2pyo(ST(i)));
     }
     PYTHON_UNLOCK;
     ASSERT_LOCK_PERL;
#line 600 "Object.c"
	{
	    SV * RETVALSV;
	    RETVALSV = 0; /* because xsubpp need 'RETVALSV =' first */
	    ASSERT_LOCK_PERL;
	    RETVALSV = newPerlPyObject_noinc(RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_dict); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_dict)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 335 "Object.xs"
     int i;
#line 622 "Object.c"
	NewPyObject *	RETVAL;
#line 337 "Object.xs"
#if 0
     printf("enter dict\n");
     //croak("croak: enter dict\n");
     PerlInterpreter *my_perl_1 = (PerlInterpreter *)Perl_get_context();
     printf("my_perl_1 = %08X\n", my_perl_1);
     extern int Perl___notused(void);
     SV **sp__ = (((PerlInterpreter *)Perl_get_context())->Istack_sp);
     printf("  1.2 %08X\n", sp__);
     I32 ax__ = S_POPMARK(((PerlInterpreter *)Perl_get_context()));
     printf("  1.3 %08X\n", ax__);
     SV **mark__ = (((PerlInterpreter *)Perl_get_context())->Istack_base) + ax__++;
     printf("  1.4 %08X\n", mark__);
     I32 items__ = (I32)(sp__ - mark__);
     printf("  1.5 %08X\n", items__);

     //     extern int Perl___notused(void);
     //     SV **sp = (((PerlInterpreter *)Perl_get_context())->Istack_sp);
     //     I32 ax = S_POPMARK(((PerlInterpreter *)Perl_get_context()));
     //     SV **mark = (((PerlInterpreter *)Perl_get_context())->Istack_base) + ax++;
     //     I32 items = (I32)(sp - mark);
     //
     //     extern int Perl___notused(void);
     //     SV **sp = (((PerlInterpreter *)Perl_get_context())->Istack_sp); 
     //     I32 ax = S_POPMARK(((PerlInterpreter *)Perl_get_context())); 
     //     SV **mark = (((PerlInterpreter *)Perl_get_context())->Istack_base) + ax++; 
     //     I32 items = (I32)(sp - mark);
#endif

     dCTX;
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     RETVAL = PyDict_New();
     if (!RETVAL)
         croak_on_py_exception();
     PERL_LOCK;
     for (i = 0; i < items; i += 2) {
        PyObject *key = sv2pyo(ST(i));
        PyObject *val;
        if (i < (items-1))
	    val = sv2pyo(ST(i+1));
	else {
	    if (PL_dowarn)
		warn("Odd number of elements in dict initializer");
            Py_INCREF(Py_None);
	    val = Py_None;
        }
	if (PyDict_SetItem(RETVAL, key, val) == -1) {
            Py_DECREF(RETVAL);
            PERL_UNLOCK;
            croak_on_py_exception();
        }
     }
     PYTHON_UNLOCK;
     ASSERT_LOCK_PERL;
#line 679 "Object.c"
	{
	    SV * RETVALSV;
	    RETVALSV = 0; /* because xsubpp need 'RETVALSV =' first */
	    ASSERT_LOCK_PERL;
	    RETVALSV = newPerlPyObject_noinc(RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyO_transplant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyO_transplant)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, donor");
    {
	SV*	self = ST(0)
;
	SV*	donor = ST(1)
;
#line 399 "Object.xs"
     /* This is only here to support the STORABLE_thaw implementation.
      * What this method does is to steal the pointer from another
      * Python::Object object.
      */
     ASSERT_LOCK_PERL;
     if (SvROK(donor) || sv_derived_from(donor, "Python::Object")) {
        MAGIC *mg;
        donor = SvRV(donor);
        mg = mg_find(donor, '~');
	if (SvIOK(donor) && mg && mg->mg_virtual == &vtbl_free_pyo) {
	   SV* self_sv = SvRV(self);
	   sv_setiv(self_sv, SvIV(donor));
           mg->mg_virtual = 0;  /* since sv_unmagic() would call it */
	   sv_unmagic(donor, '~');
	   SvOK_off(donor);

	   sv_magic(self_sv, 0, '~', 0, 0);
    	   mg = mg_find(self_sv, '~');
	   if (!mg)
		croak("Can't assign magic to Python::Object");
	    mg->mg_virtual = &vtbl_free_pyo;
            SvREADONLY(self_sv);
        }
        else
	   croak("Bad donor content");
     }
     else
	croak("Bad donor");
#line 733 "Object.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Python_PyObject_GetAttr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyObject_GetAttr)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "o, attrname");
    {
	PyObject *	o = PerlPyObject_pyo(ST(0))
;
	SV *	attrname = ST(1)
;
#line 434 "Object.xs"
     dCTX;
     PyObject *py_attrname;
#line 753 "Object.c"
	NewPyObjectX *	RETVAL;
#line 437 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     PERL_LOCK;
     py_attrname = sv2pyo(attrname);
     PERL_UNLOCK;
     RETVAL = PyObject_GetAttr(o, py_attrname);
     Py_DECREF(py_attrname);
     if (!RETVAL)
         croak_on_py_exception();
#line 765 "Object.c"
	{
	    SV * RETVALSV;
	    RETVALSV = 0; /* because xsubpp need 'RETVALSV =' first  */
	    ASSERT_LOCK_PYTHON;
	    PERL_LOCK;
	    RETVALSV = pyo2sv(RETVAL);
	    PERL_UNLOCK;
	    Py_DECREF(RETVAL);
	    ENTER_PERL;
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyObject_SetAttr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyObject_SetAttr)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "o, attrname, v");
    {
	PyObject*	o = PerlPyObject_pyo(ST(0))
;
	SV*	attrname = ST(1)
;
	SV*	v = ST(2)
;
#line 455 "Object.xs"
     dCTX;
     PyObject *py_attrname;
     PyObject *py_v;
#line 800 "Object.c"
	int	RETVAL;
	dXSTARG;
#line 459 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     PERL_LOCK;
     py_attrname = sv2pyo(attrname);
     py_v = sv2pyo(v);
     PERL_UNLOCK;
     RETVAL = PyObject_SetAttr(o, py_attrname, py_v);
     Py_DECREF(py_attrname);
     Py_DECREF(py_v);
     if (RETVAL == -1)
     	croak_on_py_exception();
     ENTER_PERL;
#line 816 "Object.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyObject_DelAttr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyObject_DelAttr)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "o, attrname");
    {
	PyObject*	o = PerlPyObject_pyo(ST(0))
;
	SV*	attrname = ST(1)
;
#line 479 "Object.xs"
     dCTX;
     PyObject *py_attrname;
#line 837 "Object.c"
	int	RETVAL;
	dXSTARG;
#line 482 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     PERL_LOCK;
     py_attrname = sv2pyo(attrname);
     PERL_UNLOCK;
     RETVAL = PyObject_DelAttr(o, py_attrname);
     Py_DECREF(py_attrname);
     if (RETVAL == -1)
     	croak_on_py_exception();
     ENTER_PERL;
#line 851 "Object.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyObject_HasAttr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyObject_HasAttr)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "o, attrname");
    {
	PyObject*	o = PerlPyObject_pyo(ST(0))
;
	SV*	attrname = ST(1)
;
#line 500 "Object.xs"
     dCTX;
     PyObject *py_attrname;
#line 872 "Object.c"
	int	RETVAL;
	dXSTARG;
#line 503 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     PERL_LOCK;
     py_attrname = sv2pyo(attrname);
     PERL_UNLOCK;
     RETVAL = PyObject_HasAttr(o, py_attrname);
     Py_DECREF(py_attrname);
     ENTER_PERL;
#line 884 "Object.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyObject_GetItem); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyObject_GetItem)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "o, key");
    {
	PyObject *	o = PerlPyObject_pyo(ST(0))
;
	SV *	key = ST(1)
;
#line 519 "Object.xs"
     dCTX;
     PyObject *py_key;
#line 905 "Object.c"
	NewPyObjectX *	RETVAL;
#line 522 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     if (PyList_Check(o) || PyTuple_Check(o)) {
	  int index;
	  ENTER_PERL;
	  index = SvIV(key);
	  ENTER_PYTHON;
	  RETVAL = PySequence_GetItem(o, index);
     }
     else {
	  PERL_LOCK;
          py_key = sv2pyo(key);
          PERL_UNLOCK;
          RETVAL = PyObject_GetItem(o, py_key);
          Py_DECREF(py_key);
     }
     if (!RETVAL)
     	croak_on_py_exception();
#line 926 "Object.c"
	{
	    SV * RETVALSV;
	    RETVALSV = 0; /* because xsubpp need 'RETVALSV =' first  */
	    ASSERT_LOCK_PYTHON;
	    PERL_LOCK;
	    RETVALSV = pyo2sv(RETVAL);
	    PERL_UNLOCK;
	    Py_DECREF(RETVAL);
	    ENTER_PERL;
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyObject_SetItem); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyObject_SetItem)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "o, key, v");
    {
	PyObject*	o = PerlPyObject_pyo(ST(0))
;
	SV*	key = ST(1)
;
	SV*	v = ST(2)
;
#line 549 "Object.xs"
     dCTX;
     PyObject *py_key;
     PyObject *py_v;
#line 961 "Object.c"
	int	RETVAL;
	dXSTARG;
#line 553 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     PERL_LOCK;
     py_v   = sv2pyo(v);
     PERL_UNLOCK;
     if (PyList_Check(o) || PyTuple_Check(o)) {
	  int index;
	  ENTER_PERL;
	  index = SvIV(key);
	  ENTER_PYTHON;
	  RETVAL = PySequence_SetItem(o, index, py_v);
     }
     else {
          PERL_LOCK;
          py_key = sv2pyo(key);
          PERL_UNLOCK;
          RETVAL = PyObject_SetItem(o, py_key, py_v);
          Py_DECREF(py_key);
     }
     Py_DECREF(py_v);
     if (RETVAL == -1)
     	croak_on_py_exception();
     ENTER_PERL;
#line 988 "Object.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyObject_DelItem); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyObject_DelItem)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "o, key");
    {
	PyObject *	o = PerlPyObject_pyo(ST(0))
;
	SV *	key = ST(1)
;
#line 584 "Object.xs"
     dCTX;
     PyObject *py_key;
#line 1009 "Object.c"
	int	RETVAL;
	dXSTARG;
#line 587 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     if (PyList_Check(o) || PyTuple_Check(o)) {
	  int index;
	  ENTER_PERL;
	  index = SvIV(key);
	  ENTER_PYTHON;
	  RETVAL = PySequence_DelItem(o, index);
     }
     else {
          PERL_LOCK;
          py_key = sv2pyo(key);
          PERL_UNLOCK;
          RETVAL = PyObject_DelItem(o, py_key);
          Py_DECREF(py_key);
     }
     if (RETVAL == -1)
     	croak_on_py_exception();
     ENTER_PERL;
#line 1032 "Object.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if PY_MAJOR_VERSION < 3
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_Python_PyObject_Compare); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyObject_Compare)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "o1, o2");
    {
	PyObject *	o1 = PerlPyObject_pyo(ST(0))
;
	PyObject *	o2 = PerlPyObject_pyo(ST(1))
;
#line 616 "Object.xs"
     dCTX;
#line 1055 "Object.c"
	int	RETVAL;
	dXSTARG;
#line 618 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     RETVAL = PyObject_Compare(o1, o2);
     if (RETVAL == -1 && PyErr_Occurred())
	croak_on_py_exception();
     ENTER_PERL;
#line 1065 "Object.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_Python_PyObject_Hash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyObject_Hash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	PyObject *	o = PerlPyObject_pyo(ST(0))
;
#line 633 "Object.xs"
     dCTX;
#line 1084 "Object.c"
	int	RETVAL;
	dXSTARG;
#line 635 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     RETVAL = PyObject_Hash(o);
     if (RETVAL == -1)
	croak_on_py_exception();
     ENTER_PERL;
#line 1094 "Object.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_id)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	PyObject *	o = PerlPyObject_pyo(ST(0))
;
	IV	RETVAL;
	dXSTARG;
#line 648 "Object.xs"
     ASSERT_LOCK_PERL;
     RETVAL = (IV)o;
#line 1115 "Object.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyObject_Length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyObject_Length)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	PyObject *	o = PerlPyObject_pyo(ST(0))
;
#line 657 "Object.xs"
     dCTX;
#line 1133 "Object.c"
	int	RETVAL;
	dXSTARG;
#line 659 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     RETVAL = PyObject_Length(o);
     if (RETVAL == -1)
	croak_on_py_exception();
     ENTER_PERL;
#line 1143 "Object.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyObject_IsTrue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyObject_IsTrue)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "o, ...");
    {
	PyObject *	o = PerlPyObject_pyo(ST(0))
;
#line 674 "Object.xs"
     dCTX;
#line 1161 "Object.c"
	int	RETVAL;
	dXSTARG;
#line 676 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     RETVAL = PyObject_IsTrue(o);
     ENTER_PERL;
#line 1169 "Object.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyObject_Type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyObject_Type)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	PyObject *	o = PerlPyObject_pyo(ST(0))
;
#line 687 "Object.xs"
     dCTX;
#line 1187 "Object.c"
	NewPyObject *	RETVAL;
#line 689 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     RETVAL = PyObject_Type(o);
     ENTER_PERL;
#line 1194 "Object.c"
	{
	    SV * RETVALSV;
	    RETVALSV = 0; /* because xsubpp need 'RETVALSV =' first */
	    ASSERT_LOCK_PERL;
	    RETVALSV = newPerlPyObject_noinc(RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyObject_Str); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyObject_Str)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "o, ...");
    {
	PyObject *	o = PerlPyObject_pyo(ST(0))
;
#line 704 "Object.xs"
     dCTX;
     PyObject *str_o;
#line 1221 "Object.c"
	SV *	RETVAL;
#line 707 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     str_o = (ix == 1) ? PyObject_Str(o) : PyObject_Repr(o);
     PERL_LOCK;
     if (str_o && PyString_Check(str_o)) {
	RETVAL = newSVpvn(PyString_AsString(str_o),
			  PyString_Size(str_o));	
     }
     else {
	RETVAL = newSV(0);
     }
     Py_XDECREF(str_o);
     PYTHON_UNLOCK;
     ASSERT_LOCK_PERL;
#line 1238 "Object.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyRun_SimpleString); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyRun_SimpleString)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "str");
    {
	char*	str = (char *)SvPV_nolen(ST(0))
;
#line 728 "Object.xs"
     dCTX;
#line 1257 "Object.c"
#line 730 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     if (PyRun_SimpleString(str) == -1) {
	/* There is no way to get at the python exception when using
	 * this entry point to the API
	 */
	ENTER_PERL;
	croak("PyRun_SimpleString failed");
     }
     ENTER_PERL;
#line 1269 "Object.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Python_eval); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_eval)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "str, ...");
    {
	char*	str = (char *)SvPV_nolen(ST(0))
;
#line 748 "Object.xs"
     dCTX;
     PyObject *globals = 0;
     PyObject *locals = 0;
#line 1289 "Object.c"
	NewPyObjectX *	RETVAL;
#line 752 "Object.xs"
     ENTER_PYTHON;
     if (items > 1) {
	printf("VK::i am here; ST(1)=%08X\n",ST(1));
	globals = PerlPyObject_pyo(ST(1));
        if (items > 2) {
	    locals = PerlPyObject_pyo(ST(2));
	    if (items > 3) {
                ENTER_PERL;
		croak("Too many arguments");
            }
        }
     }
     if (!globals) {
	PyObject *m = PyImport_AddModule("__main__");
	if (m == NULL)
	    croak_on_py_exception();
	globals = PyModule_GetDict(m);
     }
     if (!locals)
        locals = globals;

     if (!PyDict_Check(locals) || !PyDict_Check(globals))
     {
	ENTER_PERL;
	croak("The 2nd and 3rd argument must be dictionaries");
     }

     if (PyDict_GetItemString(globals, "__builtins__") == NULL) {
	   if (PyDict_SetItemString(globals, "__builtins__",
			            PyEval_GetBuiltins()) != 0)
	       croak_on_py_exception();
     }

     RETVAL = PyRun_String(str, (ix == 1) ? Py_eval_input : Py_file_input,
	                   globals, locals);
     if (!RETVAL)
	croak_on_py_exception();
#line 1329 "Object.c"
	{
	    SV * RETVALSV;
	    RETVALSV = 0; /* because xsubpp need 'RETVALSV =' first  */
	    ASSERT_LOCK_PYTHON;
	    PERL_LOCK;
	    RETVALSV = pyo2sv(RETVAL);
	    PERL_UNLOCK;
	    Py_DECREF(RETVAL);
	    ENTER_PERL;
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyObject_CallObject); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyObject_CallObject)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "o, ...");
    {
	PyObject *	o = PerlPyObject_pyo(ST(0))
;
#line 797 "Object.xs"
     dCTX;
     int i;
     PyObject *args = NULL;
#line 1360 "Object.c"
	NewPyObjectX *	RETVAL;
#line 801 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     if (!PyCallable_Check(o)) {
	ENTER_PERL;
	croak("Can't call a non-callable object");
     }

     if (items > 1) {
         PERL_LOCK;
         args = PyTuple_New(items - 1);
         for (i = 1; i < items; i++) {
             PyTuple_SetItem(args, i-1, sv2pyo(ST(i)));
         }
         PERL_UNLOCK;
     }
     RETVAL = PyObject_CallObject(o, args);
     Py_XDECREF(args);
     if (!RETVAL)
     	croak_on_py_exception();
#line 1382 "Object.c"
	{
	    SV * RETVALSV;
	    RETVALSV = 0; /* because xsubpp need 'RETVALSV =' first  */
	    ASSERT_LOCK_PYTHON;
	    PERL_LOCK;
	    RETVALSV = pyo2sv(RETVAL);
	    PERL_UNLOCK;
	    Py_DECREF(RETVAL);
	    ENTER_PERL;
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyEval_CallObjectWithKeywords); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyEval_CallObjectWithKeywords)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "o, ...");
    {
	PyObject *	o = PerlPyObject_pyo(ST(0))
;
#line 827 "Object.xs"
     dCTX;
     PyObject *alist = NULL;
     PyObject *kwdict = NULL;

     PyObject *t1 = NULL;
     PyObject *t2 = NULL;
#line 1416 "Object.c"
	NewPyObjectX *	RETVAL;
#line 834 "Object.xs"
     ASSERT_LOCK_PERL;
     if (items > 3) {
	croak("Too many arguments");
     }

     RETVAL = NULL;

     if (items >= 2) {
         /* make a tuple out of ST(1) */
	 alist = PerlPyObject_pyo_or_null(ST(1));
	 if (alist) {
	    ENTER_PYTHON;
	    if (!PyTuple_Check(alist)) {
		if (!PySequence_Check(alist)) {
		    PyErr_SetString(PyExc_TypeError,
				    "2nd argument must be a sequence");
	            goto done;
                }
		t1 = PySequence_Tuple(alist);
		if (t1 == NULL)
                    goto done;
		alist = t1;
	    }
	    ENTER_PERL;
         }
	 else {
            SV* sv = ST(1);
            if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVAV) {
		AV* av = (AV*)SvRV(sv);
		int alen = av_len(av) + 1;
		int i;

		ENTER_PYTHON;
		t1 = PyTuple_New(alen);
		if (t1 == NULL)
		    goto done;

                ENTER_PERL;
		for (i = 0; i < items; i++) {
		    SV** svp;
                    ASSERT_LOCK_PERL;
		    svp = av_fetch(av, i, 0);
		    if (svp) {
		        PyObject *item;

                        PYTHON_LOCK;
                        item = sv2pyo(*svp);

                        PERL_UNLOCK;
     			PyTuple_SetItem(t1, i, item);

			ENTER_PERL;
                    }
		}
		alist = t1;
	    }
	    else if (SvOK(sv)) {  /* not an array */
		croak("2nd argument must be an array reference");
            }
         }
     }
     if (items == 3) {
        /* make a dict out of ST(2) */
	 kwdict = PerlPyObject_pyo_or_null(ST(2));
	 if (kwdict) {
	    ENTER_PYTHON;
	    if (!PyDict_Check(alist)) { 
            }
	    ENTER_PERL;
         }
	 else {
            SV* sv = ST(2);
            if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVHV) {
		HV* hv = (HV*)SvRV(sv);
		HE* entry;

		ENTER_PYTHON;
                t2 =  PyDict_New();
		if (t2 == NULL)
		    goto done;

                ENTER_PERL;
		hv_iterinit(hv);
		while( (entry = hv_iternext(hv))) {
		    PyObject *key;
		    PyObject *val;

                    I32 klen;
                    char *kstr;
                    SV* val_sv;

                    ASSERT_LOCK_PERL;
                    kstr = hv_iterkey(entry, &klen);
                    val_sv = hv_iterval(hv, entry);

                    ENTER_PYTHON;
                    key = PyString_FromStringAndSize(kstr, klen);
                    if (key == NULL)
			goto done;

                    PERL_LOCK;
                    val = sv2pyo(val_sv);
                    PERL_UNLOCK;

		    if (PyDict_SetItem(t2, key, val) == -1)
			goto done;
                    ENTER_PERL;
                }
		kwdict = t2;
	    }
	    else if (SvOK(sv)) {  /* not a hash */
                ENTER_PYTHON;
		PyErr_SetString(PyExc_TypeError,
				"3rd argument must be a hash reference");
	        goto done;
            }
         }
     }

     ENTER_PYTHON;
     RETVAL = PyEval_CallObjectWithKeywords(o, alist, kwdict);
   done:
     Py_XDECREF(t1);
     Py_XDECREF(t2);
     if (!RETVAL)
	croak_on_py_exception();
#line 1545 "Object.c"
	{
	    SV * RETVALSV;
	    RETVALSV = 0; /* because xsubpp need 'RETVALSV =' first  */
	    ASSERT_LOCK_PYTHON;
	    PERL_LOCK;
	    RETVALSV = pyo2sv(RETVAL);
	    PERL_UNLOCK;
	    Py_DECREF(RETVAL);
	    ENTER_PERL;
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyImport_ImportModule); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyImport_ImportModule)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	char*	name = (char *)SvPV_nolen(ST(0))
;
#line 967 "Object.xs"
     dCTX;
#line 1574 "Object.c"
	NewPyObject *	RETVAL;
#line 969 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     RETVAL = PyImport_ImportModule(name);
     if (!RETVAL)
	croak_on_py_exception();
     ENTER_PERL;
#line 1583 "Object.c"
	{
	    SV * RETVALSV;
	    RETVALSV = 0; /* because xsubpp need 'RETVALSV =' first */
	    ASSERT_LOCK_PERL;
	    RETVALSV = newPerlPyObject_noinc(RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyNumber_Check); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyNumber_Check)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	SV*	o = ST(0)
;
#line 982 "Object.xs"
     dCTX;
     PyObject *pyo = PerlPyObject_pyo_or_null(o);
#line 1609 "Object.c"
	int	RETVAL;
	dXSTARG;
#line 985 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     RETVAL = pyo ? PyNumber_Check(pyo) : 0;
     ENTER_PERL;
#line 1617 "Object.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PySequence_Check); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PySequence_Check)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	SV*	o = ST(0)
;
#line 996 "Object.xs"
     dCTX;
     PyObject *pyo = PerlPyObject_pyo_or_null(o);
#line 1636 "Object.c"
	int	RETVAL;
	dXSTARG;
#line 999 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     RETVAL = pyo ? PySequence_Check(pyo) : 0;
     ENTER_PERL;
#line 1644 "Object.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyMapping_Check); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyMapping_Check)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	SV*	o = ST(0)
;
#line 1010 "Object.xs"
     dCTX;
     PyObject *pyo = PerlPyObject_pyo_or_null(o);
#line 1663 "Object.c"
	int	RETVAL;
	dXSTARG;
#line 1013 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     RETVAL = pyo ? PyMapping_Check(pyo) : 0;
     ENTER_PERL;
#line 1671 "Object.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_PyCallable_Check); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_PyCallable_Check)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	SV*	o = ST(0)
;
#line 1024 "Object.xs"
     dCTX;
     PyObject *pyo = PerlPyObject_pyo_or_null(o);
#line 1690 "Object.c"
	int	RETVAL;
	dXSTARG;
#line 1027 "Object.xs"
     ASSERT_LOCK_PERL;
     ENTER_PYTHON;
     RETVAL = pyo ? PyCallable_Check(pyo) : 0;
     ENTER_PERL;
#line 1698 "Object.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python_raise); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python_raise)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "type, value");
    {
	SV*	type = ST(0)
;
	SV*	value = ST(1)
;
#line 1040 "Object.xs"
        dCTX;
	PyObject *type_pyo;
	PyObject *value_pyo;
#line 1720 "Object.c"
#line 1044 "Object.xs"
        ASSERT_LOCK_PERL;
	PYTHON_LOCK;
	type_pyo = sv2pyo(type);
	value_pyo = sv2pyo(value);
	PERL_UNLOCK;
	PyErr_SetObject(type_pyo, value_pyo);
	croak_on_py_exception();
#line 1729 "Object.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Python__Err_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python__Err_type)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	PerlPyErr *	self = PerlPyErr_err(ST(0))
;
#line 1074 "Object.xs"
        dCTX;
#line 1747 "Object.c"
	NewPyObject *	RETVAL;
#line 1076 "Object.xs"
        ASSERT_LOCK_PERL;
	switch (ix) {
	case 1:	RETVAL = self->type;      break;
	case 2:	RETVAL = self->value;     break;
	case 3:	RETVAL = self->traceback; break;
	default: croak("Unknown attribute (%d)", ix);
        }
        ENTER_PYTHON;
        Py_XINCREF(RETVAL);
        ENTER_PERL;
#line 1760 "Object.c"
	{
	    SV * RETVALSV;
	    RETVALSV = 0; /* because xsubpp need 'RETVALSV =' first */
	    ASSERT_LOCK_PERL;
	    RETVALSV = newPerlPyObject_noinc(RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python__Err_as_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python__Err_as_string)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	PerlPyErr *	self = PerlPyErr_err(ST(0))
;
#line 1094 "Object.xs"
        dCTX;
	PyObject *str;
#line 1786 "Object.c"
	SV *	RETVAL;
#line 1097 "Object.xs"
        ASSERT_LOCK_PERL;
        ENTER_PYTHON;
	str = PyObject_Str(self->type);
        PERL_LOCK;
	RETVAL = newSVpv("", 0);
        if (str && PyString_Check(str)) {
	    sv_catpv(RETVAL, "python.");
            sv_catpv(RETVAL, PyString_AsString(str));
        }
        else
            sv_catpv(RETVAL, "python");
        Py_XDECREF(str);
        str = 0;
        PERL_UNLOCK;

        if (self->value &&
            (str = PyObject_Str(self->value)) &&
            PyString_Check(str))
        {
	    PERL_LOCK;
            sv_catpv(RETVAL, ": ");
            sv_catpv(RETVAL, PyString_AsString(str));
            PERL_UNLOCK;
        }
        Py_XDECREF(str);
        ENTER_PERL;
	if (*SvEND(RETVAL) != '\n')
	    sv_catpvn(RETVAL, "\n", 1);
#line 1817 "Object.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python__Err_as_bool); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python__Err_as_bool)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	PerlPyErr *	self = PerlPyErr_err(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 1133 "Object.xs"
        ASSERT_LOCK_PERL;
	RETVAL = 1;
#line 1839 "Object.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Python__Err_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python__Err_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	PerlPyErr *	self = PerlPyErr_err(ST(0))
;
#line 1142 "Object.xs"
        dCTX;
#line 1857 "Object.c"
#line 1144 "Object.xs"
	/* printf("Destructing Python::Err %p\n", self); */
	ASSERT_LOCK_PERL;
	ENTER_PYTHON;
	Py_XDECREF(self->type);
	Py_XDECREF(self->value);
	Py_XDECREF(self->traceback);
	ENTER_PERL;
	Safefree(self);
	ASSERT_LOCK_PERL;
#line 1868 "Object.c"
    }
    XSRETURN_EMPTY;
}

#ifdef THIS_WORKS_FOR_PY2_but_not_for_PYTHON3
#define XSubPPtmpAAAB 1


XS_EUPXS(XS_Python__Err_Exception); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Python__Err_Exception)
{
    dVAR; dXSARGS;
    dXSI32;
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 1188 "Object.xs"
        dCTX;
	PyObject* e;
#line 1887 "Object.c"
	SV *	RETVAL;
#line 1191 "Object.xs"
        ASSERT_LOCK_PERL;
        if (items > 1)
	    croak("Usage: Python::Err:Exception( [ OBJ ] )");
	switch (ix) {
	case  1: e = PyExc_Exception; break;
	case  2: e = PyExc_StandardError; break;
	case  3: e = PyExc_ArithmeticError; break;
	case  4: e = PyExc_LookupError; break;
	case  5: e = PyExc_AssertionError; break;
	case  6: e = PyExc_AttributeError; break;
	case  7: e = PyExc_EOFError; break;
	case  8: e = PyExc_FloatingPointError; break;
	case  9: e = PyExc_EnvironmentError; break;
	case 10: e = PyExc_IOError; break;
	case 11: e = PyExc_OSError; break;
	case 12: e = PyExc_ImportError; break;
	case 13: e = PyExc_IndexError; break;
	case 14: e = PyExc_KeyError; break;
	case 15: e = PyExc_KeyboardInterrupt; break;
	case 16: e = PyExc_MemoryError; break;
	case 17: e = PyExc_NameError; break;
	case 18: e = PyExc_OverflowError; break;
	case 19: e = PyExc_RuntimeError; break;
	case 20: e = PyExc_NotImplementedError; break;
	case 21: e = PyExc_SyntaxError; break;
	case 22: e = PyExc_SystemError; break;
	case 23: e = PyExc_SystemExit; break;
	case 24: e = PyExc_TypeError; break;
#if PY_MAJOR_VERSION >= 1 && PY_MINOR_VERSION >= 6
	case 25: e = PyExc_UnboundLocalError; break;
	case 26: e = PyExc_UnicodeError; break;
#endif
	case 27: e = PyExc_ValueError; break;
	case 28: e = PyExc_ZeroDivisionError; break;
	default: croak("Bad exception selector (%d)", ix); break;
	}
	if (items) {
            SV* argsv = ST(0);
	    PyObject* arg;
            if (SvROK(argsv) && sv_derived_from(argsv, "Python::Err")) {
	        arg = PerlPyErr_err(argsv)->type;
             }
             else {
		arg = PerlPyObject_pyo_or_null(argsv);
             }
            /* XXX should actually do a ISA test here */
	    RETVAL = boolSV(arg == e);
	}
	else {
	    PYTHON_LOCK;
	    RETVAL = newPerlPyObject_inc(e);
	    PYTHON_UNLOCK;
        }
	ASSERT_LOCK_PERL;
#line 1944 "Object.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}

#endif
#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Python__Object); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Python__Object)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

    {
        CV * cv;

        newXS_deffile("Python::object", XS_Python_object);
        newXS_deffile("Python::int", XS_Python_int);
        newXS_deffile("Python::long", XS_Python_long);
        newXS_deffile("Python::float", XS_Python_float);
        newXS_deffile("Python::complex", XS_Python_complex);
        newXS_deffile("Python::list", XS_Python_list);
        newXS_deffile("Python::tuple", XS_Python_tuple);
        newXS_deffile("Python::dict", XS_Python_dict);
        newXS_deffile("Python::PyO_transplant", XS_Python_PyO_transplant);
        newXS_deffile("Python::PyObject_GetAttr", XS_Python_PyObject_GetAttr);
        newXS_deffile("Python::PyObject_SetAttr", XS_Python_PyObject_SetAttr);
        newXS_deffile("Python::PyObject_DelAttr", XS_Python_PyObject_DelAttr);
        newXS_deffile("Python::PyObject_HasAttr", XS_Python_PyObject_HasAttr);
        newXS_deffile("Python::PyObject_GetItem", XS_Python_PyObject_GetItem);
        newXS_deffile("Python::PyObject_SetItem", XS_Python_PyObject_SetItem);
        newXS_deffile("Python::PyObject_DelItem", XS_Python_PyObject_DelItem);
#if XSubPPtmpAAAA
        newXS_deffile("Python::PyObject_Compare", XS_Python_PyObject_Compare);
#endif
        newXS_deffile("Python::PyObject_Hash", XS_Python_PyObject_Hash);
        newXS_deffile("Python::id", XS_Python_id);
        newXS_deffile("Python::PyObject_Length", XS_Python_PyObject_Length);
        newXS_deffile("Python::PyObject_IsTrue", XS_Python_PyObject_IsTrue);
        newXS_deffile("Python::PyObject_Type", XS_Python_PyObject_Type);
        cv = newXS_deffile("Python::PyObject_Repr", XS_Python_PyObject_Str);
        XSANY.any_i32 = 2;
        cv = newXS_deffile("Python::PyObject_Str", XS_Python_PyObject_Str);
        XSANY.any_i32 = 1;
        newXS_deffile("Python::PyRun_SimpleString", XS_Python_PyRun_SimpleString);
        cv = newXS_deffile("Python::eval", XS_Python_eval);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("Python::exec", XS_Python_eval);
        XSANY.any_i32 = 2;
        newXS_deffile("Python::PyObject_CallObject", XS_Python_PyObject_CallObject);
        newXS_deffile("Python::PyEval_CallObjectWithKeywords", XS_Python_PyEval_CallObjectWithKeywords);
        newXS_deffile("Python::PyImport_ImportModule", XS_Python_PyImport_ImportModule);
        newXS_deffile("Python::PyNumber_Check", XS_Python_PyNumber_Check);
        newXS_deffile("Python::PySequence_Check", XS_Python_PySequence_Check);
        newXS_deffile("Python::PyMapping_Check", XS_Python_PyMapping_Check);
        newXS_deffile("Python::PyCallable_Check", XS_Python_PyCallable_Check);
        newXS_deffile("Python::raise", XS_Python_raise);
        cv = newXS_deffile("Python::Err::traceback", XS_Python__Err_type);
        XSANY.any_i32 = 3;
        cv = newXS_deffile("Python::Err::type", XS_Python__Err_type);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("Python::Err::value", XS_Python__Err_type);
        XSANY.any_i32 = 2;
        newXS_deffile("Python::Err::as_string", XS_Python__Err_as_string);
        newXS_deffile("Python::Err::as_bool", XS_Python__Err_as_bool);
        newXS_deffile("Python::Err::DESTROY", XS_Python__Err_DESTROY);
#if XSubPPtmpAAAB
        cv = newXS_deffile("Python::Err::ArithmeticError", XS_Python__Err_Exception);
        XSANY.any_i32 = 3;
        cv = newXS_deffile("Python::Err::AssertionError", XS_Python__Err_Exception);
        XSANY.any_i32 = 5;
        cv = newXS_deffile("Python::Err::AttributeError", XS_Python__Err_Exception);
        XSANY.any_i32 = 6;
        cv = newXS_deffile("Python::Err::EOFError", XS_Python__Err_Exception);
        XSANY.any_i32 = 7;
        cv = newXS_deffile("Python::Err::EnvironmentError", XS_Python__Err_Exception);
        XSANY.any_i32 = 9;
        cv = newXS_deffile("Python::Err::Exception", XS_Python__Err_Exception);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("Python::Err::FloatingPointError", XS_Python__Err_Exception);
        XSANY.any_i32 = 8;
        cv = newXS_deffile("Python::Err::IOError", XS_Python__Err_Exception);
        XSANY.any_i32 = 10;
        cv = newXS_deffile("Python::Err::ImportError", XS_Python__Err_Exception);
        XSANY.any_i32 = 12;
        cv = newXS_deffile("Python::Err::IndexError", XS_Python__Err_Exception);
        XSANY.any_i32 = 13;
        cv = newXS_deffile("Python::Err::KeyError", XS_Python__Err_Exception);
        XSANY.any_i32 = 14;
        cv = newXS_deffile("Python::Err::KeyboardInterrupt", XS_Python__Err_Exception);
        XSANY.any_i32 = 15;
        cv = newXS_deffile("Python::Err::LookupError", XS_Python__Err_Exception);
        XSANY.any_i32 = 4;
        cv = newXS_deffile("Python::Err::MemoryError", XS_Python__Err_Exception);
        XSANY.any_i32 = 16;
        cv = newXS_deffile("Python::Err::NameError", XS_Python__Err_Exception);
        XSANY.any_i32 = 17;
        cv = newXS_deffile("Python::Err::NotImplementedError", XS_Python__Err_Exception);
        XSANY.any_i32 = 20;
        cv = newXS_deffile("Python::Err::OSError", XS_Python__Err_Exception);
        XSANY.any_i32 = 11;
        cv = newXS_deffile("Python::Err::OverflowError", XS_Python__Err_Exception);
        XSANY.any_i32 = 18;
        cv = newXS_deffile("Python::Err::RuntimeError", XS_Python__Err_Exception);
        XSANY.any_i32 = 19;
        cv = newXS_deffile("Python::Err::StandardError", XS_Python__Err_Exception);
        XSANY.any_i32 = 2;
        cv = newXS_deffile("Python::Err::SyntaxError", XS_Python__Err_Exception);
        XSANY.any_i32 = 21;
        cv = newXS_deffile("Python::Err::SystemError", XS_Python__Err_Exception);
        XSANY.any_i32 = 22;
        cv = newXS_deffile("Python::Err::SystemExit", XS_Python__Err_Exception);
        XSANY.any_i32 = 23;
        cv = newXS_deffile("Python::Err::TypeError", XS_Python__Err_Exception);
        XSANY.any_i32 = 24;
        cv = newXS_deffile("Python::Err::UnboundLocalError", XS_Python__Err_Exception);
        XSANY.any_i32 = 25;
        cv = newXS_deffile("Python::Err::UnicodeError", XS_Python__Err_Exception);
        XSANY.any_i32 = 26;
        cv = newXS_deffile("Python::Err::ValueError", XS_Python__Err_Exception);
        XSANY.any_i32 = 27;
        cv = newXS_deffile("Python::Err::ZeroDivisionError", XS_Python__Err_Exception);
        XSANY.any_i32 = 28;
#endif
    }

    /* Initialisation Section */

#if XSubPPtmpAAAA
#endif
#line 1053 "Object.xs"
#ifdef BOOT_FROM_PERL
	Py_Initialize();
	initperl();
	{
	    dCTX;
	    PYTHON_UNLOCK;
	}
#endif
	//printf("boot....,\n");

#if XSubPPtmpAAAB
#endif
#line 2110 "Object.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

